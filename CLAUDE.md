# NGR MVP — Claude Code Configuration

## Project Overview

This repository contains the MVP artifacts for the **Next Generation Patient Registry (NGR)** for the **Cystic Fibrosis Foundation (CFF)**. These artifacts were generated by a 5-stage AI pipeline (BA → Architect → Engineer → QA → DevOps) built on AWS Bedrock AgentCore.

**Pipeline Run ID:** `271c9944-1e04-4d3d-91b9-9c0d9b99a354`

Artifact directories were previously namespaced under this run ID; the directory structure is now flat (e.g., `src/ngr-api/`, `iac/terraform/`).

## Tech Stack (MANDATORY — dictated by CFF RFP)

| Layer | Technology |
|-------|-----------|
| Frontend | React 18 TypeScript SPA (Vite, Material-UI) |
| API | ASP.NET Core 8 Web API (C# 12) |
| Database | Azure SQL Database (EF Core 8) |
| Auth | Okta (OIDC/SAML, JWT Bearer) |
| Hosting | Azure App Services (Linux) |
| CI/CD | Azure DevOps YAML Pipelines |
| E2E Testing | Playwright (TypeScript) |
| Unit Testing | xUnit (.NET) |
| IaC | Terraform (hashicorp/azurerm ~> 3.85) |
| Monitoring | Azure Application Insights |
| Secrets | Azure Key Vault |

**Do not deviate from this stack.** Tech choices were specified by CFF in their RFP appendices.

## Key Paths

```
prd/                     # PRD, user stories, acceptance criteria
architecture/            # System design, API spec, ADRs, data model
src/ngr-api/             # ASP.NET Core 8 REST API
src/ngr-web-app/         # React 18 TypeScript SPA
src/ngr-database/        # EF Core entities, DbContext, migrations
tests/                   # xUnit test suite
iac/terraform/           # Azure infrastructure (Terraform)
iac/cicd/                # Azure DevOps pipeline YAML
iac/dockerfiles/         # Dockerfiles for API + Web
iac/docker-compose.yml   # Local dev environment
iac/runbook.md           # Operations runbook
```

## Documentation Requirement

**Every feature change or code addition must update documentation.** This is non-negotiable:
- If a UI feature is added or changed → update the relevant section of `README.md`
- If an API endpoint or auth rule is added or changed → update `README.md` and `CLAUDE.md`
- If a key path, convention, or limitation changes → update `CLAUDE.md`
- If a new service, hook, or component is introduced → note it in `CLAUDE.md` under Architecture Conventions

## RBAC UI Convention

**Buttons and actions gated by role must be disabled (never hidden) when the user lacks permission.** A `Tooltip` must explain why.

- Use the `RoleGatedButton` component (`src/ngr-web-app/src/components/RoleGatedButton.tsx`) for all role-gated actions.
- Use the `useRoles` hook (`src/ngr-web-app/src/hooks/useRoles.ts`) to read permissions from the Okta access token.
- For page-level access (e.g., direct URL navigation to `/patients/new` without the role), render an `<Alert severity="error">` explaining the required role.
- Never hide buttons from users who lack permission — always show them disabled so users understand what access they're missing and who to contact.
- `useRoles` mirrors the server-side policies in `Program.cs` exactly. When adding new policies, update both.

## Architecture Conventions

- **API pattern:** RESTful (not GraphQL). Controllers → Services → EF Core DbContext.
- **Namespaces:** All C# code uses the `NgrApi.*` namespace (e.g., `NgrApi.Models`, `NgrApi.Services`). **Not** `NGR.Api.*`.
- **Database schema:** The SQL migration scripts use the `ngr` schema. The EF Core `ApplicationDbContext` uses the default `dbo` schema. In local dev, `EnsureCreated()` auto-creates tables in `dbo`.
- **Auth flow:** Okta OIDC → JWT Bearer tokens. 4 roles: SystemAdmin, FoundationAnalyst, ProgramAdmin, ClinicalUser.
- **Form engine:** Dynamic eCRF rendering from JSON schema definitions stored in `FormDefinitions` table.
- **CORS:** Configured via `Cors:AllowedOrigins` in appsettings. The SPA calls the API via REST.
- **Secrets:** All connection strings and credentials go through Azure Key Vault. Local dev uses User Secrets or docker-compose environment variables.
- **Logging:** Serilog → Console. Application Insights sink is conditional (only enabled when connection string is configured).
- **HTTPS redirect:** Disabled in Development mode to avoid redirect loops in Docker.

## Local Development

```bash
# From iac/
docker-compose up --build -d
```

| Service | URL | Notes |
|---------|-----|-------|
| **Azure SQL Edge** | `localhost:1433` | ARM64-native; sa / `Dev!Password123`; DB: `PatientRegistryDev` |
| **ASP.NET Core API** | `http://localhost:5000` | Swagger UI at `/swagger`; health at `/health` |
| **React SPA** | `http://localhost:3000` | nginx serving Vite build on port 8080 internally |

- Database tables are **auto-created** via EF Core `EnsureCreated()` in dev mode — no manual SQL migration needed.
- Okta credentials are defaulted in docker-compose.yml but should be overridden via `.env` file or env vars.
- API healthcheck requires `curl` (installed in Dockerfile). Web healthcheck uses `wget` to `/health.txt`.
- Vite `VITE_*` env vars are passed as Docker build `args` (baked at build time), not runtime `environment`.
- Apple Silicon (M-series): Uses Azure SQL Edge instead of SQL Server 2022 (which is amd64-only).

## Azure Deployment

```bash
# From iac/terraform/
terraform init
terraform plan -var-file=environments/dev.tfvars
terraform apply -var-file=environments/dev.tfvars
```

Sensitive variables (`sql_admin_password`, `okta_client_id`, `okta_client_secret`) must be set via `-var` flags, `TF_VAR_*` environment variables, or Azure DevOps pipeline variable groups.

## What NOT to Add (Out of Scope for MVP)

- Real-time EMR integration (CSV upload is the MVP bridge)
- Patient portal
- HIE/QHIN integration
- Wearable data collection
- Real-time reporting
- Data warehouse re-platforming

The architecture must remain extensible to support all of the above in future phases.

## Known Limitations

- **Test coverage is thin** — 1 xUnit test file; needs expansion to 70%+
- **Business rules are approximated** — Form engine, ownership/sharing rules, RBAC need refinement against Appendix A/C/E
- **Data migration is not implemented** — Data model exists; PortCF ETL is out of scope
- **Form specs are stubbed** — Real eCRF machine-readable specs from CFF required
- **Secrets are placeholder** — All connection strings use placeholder values
- **Dual DbContext** — `ApplicationDbContext` (API, 14 entities, `dbo` schema) vs `NgrDbContext` (database project, 21 entities, `ngr` schema). The API uses `ApplicationDbContext`.
- **SQL migration / EF schema mismatch** — Raw SQL scripts create tables in `ngr` schema; EF Core creates in `dbo`. Use `EnsureCreated()` for local dev.
- **Azure.Identity 1.10.4** — Has known moderate security vulnerabilities (pinned by AI pipeline). Upgrade when moving toward production.

## Key Reference Documents

- **PRD:** `prd/prd.md`
- **System Design:** `architecture/system_design.md`
- **Data Model:** `architecture/data_model.md`
- **API Spec (OpenAPI 3.0):** `architecture/api_specs/api.yaml`
- **ADRs:** `architecture/adrs/`
- **Runbook:** `iac/runbook.md`

# Workflow Orchestration

## 1. Plan Mode Default
- Enter plan mode for ANY non-trivial task (3+ steps or architectural decisions)
- If something goes sideways, STOP and re-plan immediately – don't keep pushing
- Use plan mode for verification steps, not just building
- Write detailed specs upfront to reduce ambiguity

## 2. Subagent Strategy
- Use subagents liberally to keep main context window clean
- Offload research, exploration, and parallel analysis to subagents
- For complex problems, throw more compute at it via subagents
- One task per subagent for focused execution

## 3. Self-Improvement Loop
- After ANY correction from the user: update `tasks/lessons.md` with the pattern
- Write rules for yourself that prevent the same mistake
- Ruthlessly iterate on these lessons until mistake rate drops
- Review lessons at session start for relevant project

## 4. Verification Before Done
- Never mark a task complete without proving it works
- Diff behavior between main and your changes when relevant
- Ask yourself: "Would a staff engineer approve this?"
- Run tests, check logs, demonstrate correctness

## 5. Demand Elegance (Balanced)
- For non-trivial changes: pause and ask "is there a more elegant way?"
- If a fix feels hacky: "Knowing everything I know now, implement the elegant solution"
- Skip this for simple, obvious fixes – don't over-engineer
- Challenge your own work before presenting it

---

# Task Management

1. **Plan First**: Write plan to `tasks/todo.md` with checkable items
2. **Verify Plan**: Check in before starting implementation
3. **Track Progress**: Mark items complete as you go
4. **Explain Changes**: High-level summary at each step
5. **Document Results**: Add review section to `tasks/todo.md`
6. **Capture Lessons**: Update `tasks/lessons.md` after corrections

---

# Core Principles

- **Simplicity First**: Make every change as simple as possible. Impact minimal code.
- **No Laziness**: Find root causes. No temporary fixes. Senior developer standards.
- **Minimal Impact**: Changes should only touch what's necessary. Avoid introducing bugs.
